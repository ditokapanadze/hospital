import {
  BadRequestException,
  HttpException,
  Injectable,
  NotFoundException,
  UnauthorizedException,
} from "@nestjs/common";
import { Repository } from "typeorm";
import { UserEntity } from "./entitiy/user.entity";
import { InjectRepository } from "@nestjs/typeorm";
import * as argon from "argon2";
import { UserRepository } from "./users.repo";
import { Role } from "src/users/types/enum/roles.enum";
import { BaseUser, DBuser } from "src/users/types/interfaces";
import { JwtService } from "@nestjs/jwt";
import { Config } from "prettier";
import { ConfigService } from "@nestjs/config";
import { EmailService } from "src/email/email.service";
import { promises } from "dns";

import { MediaType } from "src/media/types/enums";

@Injectable()
export class UsersService {
  constructor(
    private readonly userRepo: UserRepository,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly emailService: EmailService
  ) {}

  async create(
    email: string,
    name: string,
    password: string,
    hospital?: number,
    role?: Role
  ): Promise<DBuser> {
    const newUser = await this.userRepo.createUser(
      email,
      name,
      password,
      hospital,
      role
    );

    return newUser;
  }

  public async setHashedRefreshToken(
    userId: number,

    token: string
  ) {
    const hashedRefreshToken = await argon.hash(token);
    return this.userRepo.setCurrentRefreshToken(userId, hashedRefreshToken);
  }
  public async getByRefreshToken(
    userId: number,
    refreshToken: string
  ): Promise<DBuser> {
    const user = await this.userRepo.findById(userId);

    if (!user) {
      throw new NotFoundException("User not found");
    }

    const checkToken = await argon.verify(
      user.hashedRefreshToken,
      refreshToken
    );

    if (!checkToken) {
      return void 0;
    }
    return user;
  }

  public async findByEmail(email: string): Promise<DBuser> {
    return this.userRepo.findByEmail(email);
  }

  public async findById(id: number) {
    return this.userRepo.findById(id);
  }

  public async removeRefreshToken(userId: number) {
    return this.userRepo.removeRefreshToken(userId);
  }

  public async getById(id: number) {
    return this.userRepo.findById(id);
  }

  public async createMany(
    users: any[],
    hospitalId: number,
    role: Role,
    generatedPass: boolean = false,
    hospitalName?: string
  ): Promise<DBuser[]> {
    await Promise.all(
      users.map(async (user) => {
        const password = Math.random().toString(36).slice(-8);
        const hashedPass = await argon.hash(password);

        user.password = hashedPass;
        user.role = role;

        this.emailService.doctorAndAdminVerification(
          hospitalName,
          role,
          user.email,
          password
        );

        user.autoGeneratedPassword = generatedPass;
        role === Role.DOCTOR
          ? (user.hospitalDoctor = hospitalId)
          : (user.hospitalAdmin = hospitalId);
      })
    );

    return await this.userRepo.createMany(users);
  }

  public async changePassword(
    oldPass: string,
    newPass: string,
    repeatPass: string,
    user: DBuser
  ) {
    if (newPass !== repeatPass) {
      throw new HttpException("Passwords don't match", 400);
    }
    const targetUser = await this.userRepo.findById(user.id);

    if (!targetUser) {
      throw new HttpException("User not found", 404);
    }

    const checkPass = await argon.verify(targetUser.password, oldPass);

    if (!checkPass) {
      throw new HttpException("Wrong password", 400);
    }

    if (newPass === oldPass) {
      throw new HttpException(
        "New password can not be the same as old one",
        400
      );
    }
    const hashedPass = await argon.hash(newPass);

    return await this.userRepo.changePassword(hashedPass, user.id);
  }

  async changeEmail(email: string, user: DBuser) {
    await this.checkEmail(email);

    return await this.userRepo.changeEmail(email, user.id);
  }

  public async checkEmail(email: string) {
    return this.userRepo.checkEmail(email);
  }

  public async deactivateUser(id: number, user: DBuser) {
    console.log(Number(id), user.id);
    if (user.id !== Number(id)) {
      throw new UnauthorizedException();
    }

    return await this.userRepo.deactivateUser(id);
  }

  public async verifyUser(id: number, email: string, token: string) {
    const user = await this.userRepo.findById(id);

    if (!user) {
      throw new NotFoundException("User not found");
    }
    const { email: tokenEmail } = await this.decodeToken(token);

    if (user.email !== tokenEmail) {
      throw new UnauthorizedException();
    }

    if (user.isVerified) {
      throw new BadRequestException("User already verified");
    }

    return await this.userRepo.verifyUser(id);
  }

  public async decodeToken(token: string) {
    try {
      const payLoad = await this.jwtService.verify(token, {
        secret: this.configService.get("JWT_SECRET"),
      });

      return payLoad;
    } catch (error) {
      if (error.name === "TokenExpiredError") {
        throw new BadRequestException("Token expired");
      }
      throw new BadRequestException("invalid token");
    }
  }

  public async setPasswordResetToken(id: number, token: string) {
    return this.userRepo.setPasswordResetToken(id, token);
  }

  public async resetPassword(token: string, password: string, id: number) {
    const user = await this.userRepo.findById(id);

    if (!user) {
      throw new NotFoundException("User not found");
    }

    const checkPass = await argon.verify(user.password, password);

    if (checkPass) {
      throw new HttpException("New password can  not be same as old one", 400);
    }

    const hashedPass = await argon.hash(password);

    await this.userRepo.changePassword(hashedPass, user.id);
    return await this.userRepo.setPasswordResetToken(user.id, null);
  }

  public async updateUserMedia(userId: number, mediaId: number) {
    return this.userRepo.updateUserMedia(userId, mediaId);
  }
}
